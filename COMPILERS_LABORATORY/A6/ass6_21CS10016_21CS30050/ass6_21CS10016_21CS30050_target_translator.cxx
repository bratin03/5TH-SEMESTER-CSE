/*
Assignment Number 6

Student Information:
- Bratin Mondal (Roll Number - 21CS10016)
- Somya Kumar (Roll Number - 21CS30050)
*/
#include "ass6_21CS10016_21CS30050_translator.h"

#include <iostream>
#include <string>
#include <fstream>

using namespace std;

extern FILE *yyin;
extern vector<string> stringsToBePrinted; // by printString meth

int functionLabelCount = 0;
map<int, int> labelSerialNumber;									// map from quad number to label number
ofstream out;														// asm file stream
vector<quad> Array;													// quad Array
string asmFileName = "./testcases/output/ass6_21CS10016_21CS30050"; // asm file name
string testFileName = "./testcases/input/ass6_21CS10016_21CS30050"; // input file name

// Function to check if a string is a number
bool isNumber(string s)
{
	// If the string is empty, it's not a number
	if (s.empty())
		return false;

	// If the string starts with a '-' or '+', remove it for further checking
	if (s[0] == '-' || s[0] == '+')
		s = s.substr(1);

	// If the string is empty after removing '-' or '+', it's not a number
	if (s.empty())
		return false;

	// Check each character in the string, if any character is not a digit, it's not a number
	for (auto u : s)
		if (!isdigit(u))
			return false;

	// If all characters are digits, it's a number
	return true;
}

// Function to compute the activation record of a symbol table
void computeActivationRecord(symtable *st)
{
	// Initialize the offset for parameters and local variables
	int param_offset = -20;
	int locals_offset = -24;

	// Iterate over all symbols in the symbol table
	for (auto &it : st->symbols)
	{
		// If the symbol is a parameter, assign it the current parameter offset and increment the offset by the size of the symbol
		if (it.category == "param")
		{
			st->ActivationRecord[it.name] = param_offset;
			param_offset += it.size;
		}
		// If the symbol is a local variable (and not the return value), assign it the current local variable offset and decrement the offset by the size of the symbol
		else if (it.name != "return")
		{
			st->ActivationRecord[it.name] = locals_offset;
			locals_offset -= it.size;
		}
	}
	return;
}

inline int getOffset(string arg)
{
	return ST->ActivationRecord[arg];
}

// Some helper functions used for optimization
inline bool isPowerOfTwo(int num)
{
	return (num & (num - 1)) == 0 && num > 0;
}

int logBaseTwo(int val)
{
	int ans = 0;
	while (val != 1)
	{
		ans++;
		val >>= 1;
	}
	return ans;
}

void generateAsm()
{
	// We are generating the .s file here
	// Add the quads for the three address codes
	Array = Q.Array;

	for (auto &u : Array)
	{
		const auto v = u.op;
		vector<string> operations = {"goto", "<", ">", "<=", ">=", "==", "!="};

		for (auto &operation : operations)
			if (v == operation)
			{
				int targetLabel = stoi(u.res);
				labelSerialNumber[targetLabel] = 1;
			}
	}

	// Basically we assign a unique map to each unique label using prefix sums
	for (auto it = labelSerialNumber.begin(); it != labelSerialNumber.end(); ++it)
	{
		if (it != labelSerialNumber.begin())
		{
			auto previous = prev(it);
			it->second += previous->second;
		}
	}

	// flatten the global ST
	list<symtable *> tableList;

	for (auto &it : ST->symbols)
		if (it.nested != NULL)
			tableList.push_back(it.nested);

	// compute activation record for each
	for (auto it : tableList)
		computeActivationRecord(it);

	ofstream asmFile;
	asmFile.open(asmFileName + ".s", std::ofstream::out);

	asmFile << "/*\n";
	asmFile << " * @file " << asmFileName << ".s\n";
	asmFile << " * @brief This file contains the assembly code for the input source file.\n";
	asmFile << " * It is generated by the tinyC Compiler.\n";
	asmFile << "Assignment Number 6\n";
	asmFile << "Student Information:\n - Bratin Mondal(Roll Number - 21CS10016)\n - Somya Kumar(Roll Number - 21CS30050)\n ";
	asmFile << " */\n\n";

	// beginning of the .s file
	asmFile << "\t.file\t";
	asmFile << "\"" << testFileName << ".c\"\n";

	asmFile << "\t.text\n";

	// Iterate over all symbols in the symbol table
	for (auto &it : ST->symbols)
	{
		// If the symbol is not a function
		if (it.category != "function")
		{
			// If the symbol has a value
			if (it.val != "")
			{
				// If the symbol is a character
				if (it.type->type == "char")
				{
					// Declare the symbol as a global object
					asmFile << "\t.globl\t" << it.name << "\n";
					// Specify the type of the symbol
					asmFile << "\t.type\t" << it.name << ", @object\n";
					// Specify the size of the symbol
					asmFile << "\t.size\t" << it.name << ", 1\n";
					// Label the symbol
					asmFile << it.name << ":\n";
					// Initialize the symbol with its value
					asmFile << "\t.byte\t" << it.val << "\n";
				}
				// If the symbol is an integer
				else if (it.type->type == "int")
				{
					// Declare the symbol as a global object
					asmFile << "\t.globl\t" << it.name << "\n";
					// Start the data section
					asmFile << "\t.data\n";
					// Align the data to 4 bytes
					asmFile << "\t.align 4\n";
					// Specify the type of the symbol
					asmFile << "\t.type\t" << it.name << ", @object\n";
					// Specify the size of the symbol
					asmFile << "\t.size\t" << it.name << ", 4\n";
					// Label the symbol
					asmFile << it.name << ":\n";
					// Initialize the symbol with its value
					asmFile << "\t.long\t" << it.val << "\n";
				}
				// If the symbol is a float
				else if (it.type->type == "float")
				{
					// Declare the symbol as a global object
					asmFile << "\t.globl\t" << it.name << "\n";
					// Start the data section
					asmFile << "\t.data\n";
					// Align the data to 4 bytes
					asmFile << "\t.align 4\n";
					// Specify the type of the symbol
					asmFile << "\t.type\t" << it.name << ", @object\n";
					// Specify the size of the symbol
					asmFile << "\t.size\t" << it.name << ", 4\n";
					// Label the symbol
					asmFile << it.name << ":\n";
					// Initialize the symbol with its value
					asmFile << "\t.float\t" << it.val << "\n";
				}
			}
			else
			{
				// If the symbol doesn't have a value, reserve space for it in the memory
				asmFile << "\t.comm\t" << it.name << ", " << it.size << ", " << it.size << "\n";
			}
		}
	}
	int cnt = 0;
	// Dealing with the strings to be printed in the program
	if (!stringsToBePrinted.empty())
	{
		asmFile << "\t.section\t.rodata\n";

		for (auto &it : stringsToBePrinted)
		{
			asmFile << ".LC" << cnt++ << ":\n";
			asmFile << "\t.string\t" << it << "\n";
		}
	}
	int cnt2 = cnt;
	if (!floatsToBePrinted.empty())
	{
		asmFile << "\t.section\t.rodata\n";

		for (auto &it : floatsToBePrinted)
		{
			asmFile << ".LC" << cnt++ << ":\n";
			asmFile << "\t.float\t" << it << "\n";
		}
	}

	asmFile << ".LC" << cnt++ << ":\n";
	asmFile << "\t.float\t" << -1 << "\n";

	// beginning of the text section
	asmFile << "\t.text\n";

	vector<string> params;

	int opSerialNumber = 0;

	for (auto it : Array)
	{
		if (labelSerialNumber.count(opSerialNumber))
			asmFile << ".L" << labelSerialNumber[opSerialNumber] << ": " << '\n';

		string op = it.op;
		string arg1 = it.arg1;
		string arg2 = it.arg2;
		string res = it.res;
		string s = arg2; // change this later

		// if param -> add to the param list
		if (op == "param")
		{
			params.push_back(res);
		}
		else
		{

			// Binary Operations

			// addition operation
			if (op == "+")
			{
				// Lookup the type of the result to determine the operation to perform
				sym *resEntry = ST->lookup(res);
				string res_type = resEntry->type->type;

				if (res_type == "int")
				{
					// Integer addition
					asmFile << "\tmovl\t" << getOffset(arg1) << "(%rbp), %eax\n";
					if (isNumber(arg2))
					{
						int toAdd = stoi(arg2);
						if (toAdd == 1)
						{
							// optimization using inc
							asmFile << "\tincl\t%eax\n";
						}
						else
						{
							asmFile << "\taddl\t$" << arg2 << ", %eax\n";
						}
					}
					else
					{
						asmFile << "\taddl\t" << getOffset(arg2) << "(%rbp), %eax\n";
					}
					asmFile << "\tmovl\t%eax, " << getOffset(res) << "(%rbp)\n";
				}
				else if (res_type == "float")
				{
					// Floating-point addition
					asmFile << "\tmovss\t" << getOffset(arg1) << "(%rbp), %xmm0\n";
					if (isNumber(arg2))
					{
						// In a real compiler, you'd need to have the floating point number in memory
						// or a register to add it using addss. This assumes it's already in memory.
						asmFile << "\taddss\t" << getOffset(arg2) << "(%rbp), %xmm0\n";
					}
					else
					{
						// Directly add from memory to xmm0
						asmFile << "\taddss\t" << getOffset(arg2) << "(%rbp), %xmm0\n";
					}
					asmFile << "\tmovss\t%xmm0, " << getOffset(res) << "(%rbp)\n";
				}
				else
				{
					// Handle error for unsupported types
				}
			}

			else if (op == "-")
			{
				// Lookup the type of the result to determine the operation to perform
				sym *resEntry = ST->lookup(res);
				string res_type = resEntry->type->type;

				if (res_type == "int")
				{
					// Integer subtraction
					asmFile << "\tmovl\t" << getOffset(arg1) << "(%rbp), %eax\n";
					asmFile << "\tmovl\t" << getOffset(arg2) << "(%rbp), %edx\n";
					asmFile << "\tsubl\t%edx, %eax\n";
					asmFile << "\tmovl\t%eax, " << getOffset(res) << "(%rbp)\n";
				}
				else if (res_type == "float")
				{
					// Floating-point subtraction
					asmFile << "\tmovss\t" << getOffset(arg1) << "(%rbp), %xmm0\n";
					asmFile << "\tmovss\t" << getOffset(arg2) << "(%rbp), %xmm1\n"; // Use another xmm register to hold the second operand
					asmFile << "\tsubss\t%xmm1, %xmm0\n";							// Perform the subtraction
					asmFile << "\tmovss\t%xmm0, " << getOffset(res) << "(%rbp)\n";	// Move the result back to the location of res
				}
				else
				{
					// Handle error for unsupported types
				}
			}

			else if (op == "*")
			{
				// Lookup the type of the result to determine the operation to perform
				sym *resEntry = ST->lookup(res);
				string res_type = resEntry->type->type;

				if (res_type == "int")
				{
					// Integer multiplication
					asmFile << "\tmovl\t" << getOffset(arg1) << "(%rbp), %eax\n";
					if (isNumber(arg2))
					{
						int multiplier = stoi(arg2);
						if (isPowerOfTwo(multiplier))
						{
							// Strength reduction for power of two multiplication
							asmFile << "\tsall\t$" << logBaseTwo(multiplier) << ", %eax\n";
						}
						else
						{
							asmFile << "\timull\t$" << multiplier << ", %eax\n";
						}
					}
					else
					{
						asmFile << "\timull\t" << getOffset(arg2) << "(%rbp), %eax\n";
					}
					asmFile << "\tmovl\t%eax, " << getOffset(res) << "(%rbp)\n";
				}
				else if (res_type == "float")
				{
					// Floating-point multiplication
					asmFile << "\tmovss\t" << getOffset(arg1) << "(%rbp), %xmm0\n";
					asmFile << "\tmulss\t" << getOffset(arg2) << "(%rbp), %xmm0\n";
					asmFile << "\tmovss\t%xmm0, " << getOffset(res) << "(%rbp)\n";
				}
				else
				{
					// Handle error for unsupported types
				}
			}

			else if (op == "/")
			{
				// Lookup the type of the result to determine the operation to perform
				sym *resEntry = ST->lookup(res);
				string res_type = resEntry->type->type;

				if (res_type == "int")
				{
					// Integer division
					asmFile << "\tmovl\t" << getOffset(arg1) << "(%rbp), %eax\n";
					asmFile << "\tcltd\n";										 // Sign-extend EAX into EDX:EAX for division
					asmFile << "\tidivl\t" << getOffset(arg2) << "(%rbp)\n";	 // Divide EDX:EAX by operand
					asmFile << "\tmovl\t%eax, " << getOffset(res) << "(%rbp)\n"; // Store quotient in result
				}
				else if (res_type == "float")
				{
					// Floating-point division
					asmFile << "\tmovss\t" << getOffset(arg1) << "(%rbp), %xmm0\n";
					asmFile << "\tdivss\t" << getOffset(arg2) << "(%rbp), %xmm0\n";
					asmFile << "\tmovss\t%xmm0, " << getOffset(res) << "(%rbp)\n"; // Store result
				}
				else
				{
					// Handle error for unsupported types
				}
			}

			// modulo operation
			else if (op == "%")
			{
				asmFile << "\tmovl \t" << getOffset(arg1) << "(%rbp), "
						<< "%eax" << '\n';
				asmFile << "\tcltd" << '\n';
				asmFile << "\tidivl \t" << getOffset(arg2) << "(%rbp)" << '\n';
				asmFile << "\tmovl \t%edx, " << getOffset(res) << "(%rbp)";
			}

			// Ignoring bitwise operations
			else if (op == "^")
				asmFile << "\t" << res << " = " << arg1 << " ^ " << arg2;
			else if (op == "|")
				asmFile << "\t" << res << " = " << arg1 << " | " << arg2;
			else if (op == "&")
				asmFile << "\t" << res << " = " << arg1 << " & " << arg2;

			// Ignoring shift operations
			else if (op == "<<")
				asmFile << "\t" << res << " = " << arg1 << " << " << arg2;
			else if (op == ">>")
				asmFile << "\t" << res << " = " << arg1 << " >> " << arg2;
			else if (op == "equalchar")
				asmFile << "\tmovb\t$" << arg1 << ", " << getOffset(res) << "(%rbp)";

			else if (op == "equalstr")
				asmFile << "\tmovq \t$.LC" << arg1 << ", " << getOffset(res) << "(%rbp)";
			else if (op == "equalfloat")
			{
				asmFile << "\tmovss\t.LC" << to_string(stoi(arg1) + cnt2) << "(%rip), %xmm0\n";
				asmFile << "\tmovss\t%xmm0, " << getOffset(res) << "(%rbp)\n"; // Move value from xmm0 into res's location
			}
			// assignment
			else if (op == "=")
			{
				sym *temp = ST->lookup(res);
				if (temp->type->type == "int")
				{
					if (isNumber(arg1))
						asmFile << "\tmovl\t$" << arg1 << ", "
								<< "%eax" << '\n';
					else
						asmFile << "\tmovl\t" << getOffset(arg1) << "(%rbp), "
								<< "%eax" << '\n';

					asmFile << "\tmovl \t%eax, " << getOffset(res) << "(%rbp)";
				}
				else if (temp->type->type == "float")
				{
					asmFile << "\tmovss\t" << getOffset(arg1) << "(%rbp), %xmm0\n"; // Move value from arg1's location into xmm0
					asmFile << "\tmovss\t%xmm0, " << getOffset(res) << "(%rbp)\n";	// Move value from xmm0 into res's location
				}
			}

			// dereferencing

			// Relational Operations
			else if (op == "==")
			{
				// This block handles the '==' operation

				// Lookup the first argument in the symbol table
				sym *temp = ST->lookup(arg1);

				// If the type of the first argument is char
				if (temp->type->type == "char")
				{
					// Move the first argument to the AL register
					asmFile << "\tmovb\t" << getOffset(arg1) << "(%rbp), %al\n";
					// Compare the second argument with the AL register
					asmFile << "\tcmpb\t" << getOffset(arg2) << "(%rbp), %al\n";
					// If AL is equal to the second argument, jump to the label specified by the result
					asmFile << "\tje .L" << labelSerialNumber[stoi(res)];
				}
				// If the type of the first argument is int
				else if (temp->type->type == "int")
				{
					// Move the first argument to the EAX register
					asmFile << "\tmovl\t" << getOffset(arg1) << "(%rbp), %eax\n";
					// Compare the second argument with the EAX register
					asmFile << "\tcmpl\t" << getOffset(arg2) << "(%rbp), %eax\n";
					// If EAX is equal to the second argument, jump to the label specified by the result
					asmFile << "\tje .L" << labelSerialNumber[stoi(res)];
				}
				// If the type of the first argument is float
				else if (temp->type->type == "float")
				{
					// Move the first argument to the XMM0 register
					asmFile << "\tmovss\t" << getOffset(arg1) << "(%rbp), %xmm0\n";
					// Compare the second argument with the XMM0 register
					asmFile << "\tucomiss\t" << getOffset(arg2) << "(%rbp), %xmm0\n";
					// If XMM0 is equal to the second argument, jump to the label specified by the result
					asmFile << "\tje .L" << labelSerialNumber[stoi(res)];
				}
				else
				{
					// If the type of the first argument is not char, int, or float, do nothing
				}
			}

			else if (op == "!=")
			{
				sym *temp = ST->lookup(arg1);
				if (temp->type->type == "char")
				{
					asmFile << "\tmovb\t" << getOffset(arg1) << "(%rbp), %al\n";
					asmFile << "\tcmpb\t" << getOffset(arg2) << "(%rbp), %al\n";
					asmFile << "\tjne .L" << labelSerialNumber[stoi(res)];
				}
				else if (temp->type->type == "int")
				{
					asmFile << "\tmovl\t" << getOffset(arg1) << "(%rbp), %eax\n";
					asmFile << "\tcmpl\t" << getOffset(arg2) << "(%rbp), %eax\n";
					asmFile << "\tjne .L" << labelSerialNumber[stoi(res)];
				}
				else if (temp->type->type == "float")
				{
					asmFile << "\tmovss\t" << getOffset(arg1) << "(%rbp), %xmm0\n";
					asmFile << "\tucomiss\t" << getOffset(arg2) << "(%rbp), %xmm0\n";
					asmFile << "\tjne .L" << labelSerialNumber[stoi(res)];
				}
				else
				{
				}
			}
			else if (op == "<")
			{
				sym *temp = ST->lookup(arg1);
				if (temp->type->type == "char")
				{
					asmFile << "\tmovb\t" << getOffset(arg1) << "(%rbp), %al\n";
					asmFile << "\tcmpb\t" << getOffset(arg2) << "(%rbp), %al\n";
					asmFile << "\tjl .L" << labelSerialNumber[stoi(res)];
				}
				else if (temp->type->type == "int")
				{
					asmFile << "\tmovl\t" << getOffset(arg1) << "(%rbp), %eax\n";
					asmFile << "\tcmpl\t" << getOffset(arg2) << "(%rbp), %eax\n";
					asmFile << "\tjl .L" << labelSerialNumber[stoi(res)];
				}
				else if (temp->type->type == "float")
				{
					asmFile << "\tmovss\t" << getOffset(arg1) << "(%rbp), %xmm0\n";
					asmFile << "\tucomiss\t" << getOffset(arg2) << "(%rbp), %xmm0\n";
					asmFile << "\tjl .L" << labelSerialNumber[stoi(res)];
				}
				else
				{
				}
			}
			else if (op == ">")
			{
				// This block handles the '>' operation

				// Lookup the first argument in the symbol table
				sym *temp = ST->lookup(arg1);

				// If the type of the first argument is char
				if (temp->type->type == "char")
				{
					// Move the first argument to the AL register
					asmFile << "\tmovb\t" << getOffset(arg1) << "(%rbp), %al\n";
					// Compare the second argument with the AL register
					asmFile << "\tcmpb\t" << getOffset(arg2) << "(%rbp), %al\n";
					// If AL is greater than the second argument, jump to the label specified by the result
					asmFile << "\tjg .L" << labelSerialNumber[stoi(res)];
				}
				// If the type of the first argument is int
				else if (temp->type->type == "int")
				{
					// Move the first argument to the EAX register
					asmFile << "\tmovl\t" << getOffset(arg1) << "(%rbp), %eax\n";
					// Compare the second argument with the EAX register
					asmFile << "\tcmpl\t" << getOffset(arg2) << "(%rbp), %eax\n";
					// If EAX is greater than the second argument, jump to the label specified by the result
					asmFile << "\tjg .L" << labelSerialNumber[stoi(res)];
				}
				// If the type of the first argument is float
				else if (temp->type->type == "float")
				{
					// Move the first argument to the XMM0 register
					asmFile << "\tmovss\t" << getOffset(arg1) << "(%rbp), %xmm0\n";
					// Compare the second argument with the XMM0 register
					asmFile << "\tucomiss\t" << getOffset(arg2) << "(%rbp), %xmm0\n";
					// If XMM0 is greater than the second argument, jump to the label specified by the result
					asmFile << "\tjg .L" << labelSerialNumber[stoi(res)];
				}
				else
				{
					// If the type of the first argument is not char, int, or float, do nothing
				}
			}
			else if (op == ">=")
			{
				// This block handles the '>=' operation

				// Lookup the first argument in the symbol table
				sym *temp = ST->lookup(arg1);

				// If the type of the first argument is char
				if (temp->type->type == "char")
				{
					// Move the first argument to the AL register
					asmFile << "\tmovb\t" << getOffset(arg1) << "(%rbp), %al\n";
					// Compare the second argument with the AL register
					asmFile << "\tcmpb\t" << getOffset(arg2) << "(%rbp), %al\n";
					// If AL is greater than or equal to the second argument, jump to the label specified by the result
					asmFile << "\tjge .L" << labelSerialNumber[stoi(res)];
				}
				// If the type of the first argument is int
				else if (temp->type->type == "int")
				{
					// Move the first argument to the EAX register
					asmFile << "\tmovl\t" << getOffset(arg1) << "(%rbp), %eax\n";
					// Compare the second argument with the EAX register
					asmFile << "\tcmpl\t" << getOffset(arg2) << "(%rbp), %eax\n";
					// If EAX is greater than or equal to the second argument, jump to the label specified by the result
					asmFile << "\tjge .L" << labelSerialNumber[stoi(res)];
				}
				// If the type of the first argument is float
				else if (temp->type->type == "float")
				{
					// Move the first argument to the XMM0 register
					asmFile << "\tmovss\t" << getOffset(arg1) << "(%rbp), %xmm0\n";
					// Compare the second argument with the XMM0 register
					asmFile << "\tucomiss\t" << getOffset(arg2) << "(%rbp), %xmm0\n";
					// If XMM0 is greater than or equal to the second argument, jump to the label specified by the result
					asmFile << "\tjge .L" << labelSerialNumber[stoi(res)];
				}
				else
				{
					// If the type of the first argument is not char, int, or float, do nothing
				}
			}
			else if (op == "<=")
			{
				// This block handles the '<=' operation

				// Lookup the first argument in the symbol table
				sym *temp = ST->lookup(arg1);

				// If the type of the first argument is char
				if (temp->type->type == "char")
				{
					// Move the first argument to the AL register
					asmFile << "\tmovb\t" << getOffset(arg1) << "(%rbp), %al\n";
					// Compare the second argument with the AL register
					asmFile << "\tcmpb\t" << getOffset(arg2) << "(%rbp), %al\n";
					// If AL is less than or equal to the second argument, jump to the label specified by the result
					asmFile << "\tjle .L" << labelSerialNumber[stoi(res)];
				}
				// If the type of the first argument is int
				else if (temp->type->type == "int")
				{
					// Move the first argument to the EAX register
					asmFile << "\tmovl\t" << getOffset(arg1) << "(%rbp), %eax\n";
					// Compare the second argument with the EAX register
					asmFile << "\tcmpl\t" << getOffset(arg2) << "(%rbp), %eax\n";
					// If EAX is less than or equal to the second argument, jump to the label specified by the result
					asmFile << "\tjle .L" << labelSerialNumber[stoi(res)];
				}
				// If the type of the first argument is float
				else if (temp->type->type == "float")
				{
					// Move the first argument to the XMM0 register
					asmFile << "\tmovss\t" << getOffset(arg1) << "(%rbp), %xmm0\n";
					// Compare the second argument with the XMM0 register
					asmFile << "\tucomiss\t" << getOffset(arg2) << "(%rbp), %xmm0\n";
					// If XMM0 is less than or equal to the second argument, jump to the label specified by the result
					asmFile << "\tjle .L" << labelSerialNumber[stoi(res)];
				}
				else
				{
					// If the type of the first argument is not char, int, or float, do nothing
				}
			}
			else if (op == "goto")
			{
				// This block handles the 'goto' operation

				// Jump to the label specified by the result
				asmFile << "\tjmp .L" << labelSerialNumber[stoi(res)];
			}

			// Unary Operators
			// Extracting the address
			else if (op == "=&")
			{
				asmFile << "\tleaq\t" << getOffset(arg1) << "(%rbp), %rax\n";
				asmFile << "\tmovq \t%rax, " << getOffset(res) << "(%rbp)";
			}
			// a = *b
			else if (op == "=*")
			{
				// Assume symtable lookup tells us whether it's a float or int
				sym *s1 = ST->lookup(arg1);
				sym *s2 = ST->lookup(res);

				if (s1->type->type == "float")
				{
					// Floating-point dereferencing
					asmFile << "\tmovq\t" << getOffset(arg1) << "(%rbp), %rax\n";  // Move pointer address into rax
					asmFile << "\tmovss\t(%rax), %xmm0\n";						   // Move float value from pointer address into xmm0
					asmFile << "\tmovss\t%xmm0, " << getOffset(res) << "(%rbp)\n"; // Move float value from xmm0 into destination
				}
				else if (s1->type->type == "int")
				{
					// Integer dereferencing (original code)
					asmFile << "\tmovq\t" << getOffset(arg1) << "(%rbp), %rax\n"; // Move pointer address into rax
					asmFile << "\tmovl\t(%rax), %eax\n";						  // Move int value from pointer address into eax
					asmFile << "\tmovl\t%eax, " << getOffset(res) << "(%rbp)\n";  // Move int value from eax into destination
				}
				else
				{
					// Handle other types or throw an error
				}
			}

			else if (op == "*=")
			{
				// Lookup the type of arg1 to determine the operation to perform
				sym *arg1Entry = ST->lookup(arg1);
				string arg1_type = arg1Entry->type->type;

				if (arg1_type == "int")
				{
					// Integer assignment through pointer dereference
					asmFile << "\tmovq\t" << getOffset(res) << "(%rbp), %rax\n";  // Load address into rax
					asmFile << "\tmovl\t" << getOffset(arg1) << "(%rbp), %edx\n"; // Load integer into edx
					asmFile << "\tmovl\t%edx, (%rax)\n";						  // Store integer at the dereferenced address
				}
				else if (arg1_type == "float")
				{
					// Floating-point assignment through pointer dereference
					asmFile << "\tmovq\t" << getOffset(res) << "(%rbp), %rax\n";	// Load address into rax
					asmFile << "\tmovss\t" << getOffset(arg1) << "(%rbp), %xmm0\n"; // Load float into xmm0
					asmFile << "\tmovss\t%xmm0, (%rax)\n";							// Store float at the dereferenced address
				}
				else
				{
					// Handle error for unsupported types
				}
			}

			// a = -b
			else if (op == "uminus")
			{
				// Lookup the type of arg1 to determine the operation to perform
				sym *arg1Entry = ST->lookup(arg1);
				string arg1_type = arg1Entry->type->type;

				if (arg1_type == "int")
				{
					// Integer negation
					if (isNumber(arg1))
						asmFile << "\tmovl\t$" << arg1 << ", %eax\n"; // Move immediate value into eax
					else
						asmFile << "\tmovl\t" << getOffset(arg1) << "(%rbp), %eax\n"; // Move integer from memory into eax

					asmFile << "\tnegl\t%eax\n";								 // Negate the integer in eax
					asmFile << "\tmovl\t%eax, " << getOffset(res) << "(%rbp)\n"; // Store the result back into memory
				}
				else if (arg1_type == "float")
				{
					// Floating-point negation
					// Load the constant -1.0 into an xmm register
					asmFile << "\tmovss\t.LC" << cnt - 1 << "(%rip), %xmm1\n";		// Assume .LC0 is the label for the constant -1.0
					asmFile << "\tmovss\t" << getOffset(arg1) << "(%rbp), %xmm0\n"; // Move float from memory into xmm0

					asmFile << "\tmulss\t%xmm1, %xmm0\n";						   // Multiply by -1.0 to negate the float
					asmFile << "\tmovss\t%xmm0, " << getOffset(res) << "(%rbp)\n"; // Store the result back into memory
				}
				else
				{
					// Handle error for unsupported types
				}
			}

			else if (op == "~")
				asmFile << res << " = ~" << arg1;
			else if (op == "!")
				asmFile << res << " = !" << arg1;

			else if (op == "=[]")
			{
				sym *arg1Entry = ST->lookup(arg1);
				string arg1_type = arg1Entry->type->type;

				// Calculate the index and base address
				asmFile << "\tmovl\t" << getOffset(arg2) << "(%rbp), %eax\n";
				asmFile << "\tnegl\t%eax\n";
				asmFile << "\tcltq\n"; // Convert long to quad, sign extending %eax to %rax

				// Load the appropriate value from the address into a register
				if (arg1_type == "int")
				{
					asmFile << "\tmovl\t" << getOffset(arg1) << "(%rbp, %rax, 4), %eax\n"; // Use 4 for int size
					asmFile << "\tmovl\t%eax, " << getOffset(res) << "(%rbp)\n";
				}
				else if (arg1_type == "float")
				{
					asmFile << "\tmovss\t" << getOffset(arg1) << "(%rbp, %rax, 4), %xmm0\n"; // Use 4 for float size
					asmFile << "\tmovss\t%xmm0, " << getOffset(res) << "(%rbp)\n";
				}
				else if (arg1_type == "char")
				{
					asmFile << "\tmovb\t" << getOffset(arg1) << "(%rbp, %rax, 1), %al\n"; // Use 1 for char size
					asmFile << "\tmovb\t%al, " << getOffset(res) << "(%rbp)\n";
				}
				else
				{
					// Handle error for unsupported types
				}
			}

			else if (op == "[]=")
			{
				sym *resEntry = ST->lookup(res);
				string res_type = resEntry->type->type;

				// Calculate the index and base address
				asmFile << "\tmovl\t" << getOffset(arg2) << "(%rbp), %edx\n";
				asmFile << "\tmovl\t" << getOffset(arg1) << "(%rbp), %eax\n";
				asmFile << "\tnegl\t%eax\n";
				asmFile << "\tcltq\n"; // Convert long to quad, sign extending %eax to %rax

				// Store the value from a register into the appropriate address
				if (res_type == "int")
				{
					asmFile << "\tmovl\t%edx, " << getOffset(res) << "(%rbp, %rax, 4)\n"; // Use 4 for int size
				}
				else if (res_type == "float")
				{
					asmFile << "\tmovss\t%xmm0, " << getOffset(res) << "(%rbp, %rax, 4)\n"; // Use 4 for float size, assuming %xmm0 already contains the value
				}
				else if (res_type == "char")
				{
					asmFile << "\tmovb\t%dl, " << getOffset(res) << "(%rbp, %rax, 1)\n"; // Use 1 for char size
				}
				else
				{
					// Handle error for unsupported types
				}
			}

			else if (op == "return")
			{
				if (res != "")
				{
					// Lookup the type of res to determine the operation to perform
					sym *resEntry = ST->lookup(res);
					string res_type = resEntry->type->type;

					// Integer and pointer types
					if (res_type == "int" || res_type == "ptr")
					{
						asmFile << "\tmovq\t" << getOffset(res) << "(%rbp), %rax\n"; // Move result into rax
					}
					// Single-precision floats
					else if (res_type == "float")
					{
						asmFile << "\tmovss\t" << getOffset(res) << "(%rbp), %xmm0\n"; // Move result into xmm0
					}
					// Characters
					else if (res_type == "char")
					{
						asmFile << "\tmovb\t" << getOffset(res) << "(%rbp), %al\n"; // Move result into al (lower 8 bits of rax)
					}
					else
					{
						// Handle error for unsupported types
					}
				}
				else
				{
					// Handle void return type
					asmFile << "\tnop\n"; // No operation is needed for void return type
				}
				// Add common function return sequence here, if needed
			}

			else if (op == "param")
			{
				params.push_back(res);
			}

			// call a function
			else if (op == "call")
			{
				// Function Table

				// Iterate over all parameters
				for (int paramCount = 0; paramCount < (int)params.size(); paramCount++)
				{
					// Lookup the parameter in the symbol table
					sym *paramEntry = ST->lookup(params[paramCount]);
					// Get the type of the parameter
					string param_type = paramEntry->type->type;
					// Get the offset of the parameter
					int ourOffset = getOffset(params[paramCount]);
					// Initialize the count of floating-point parameters
					int floatParamCount = 0;

					// If the type of the parameter is int, char, or pointer
					if (param_type == "int" || param_type == "char" || param_type == "ptr")
					{
						// Move the parameter from the memory location to the appropriate register based on the parameter count
						if (paramCount == 0)
							asmFile << "\tmovq \t" << ourOffset << "(%rbp), "
									<< "%rdi" << '\n';
						else if (paramCount == 1)
							asmFile << "\tmovq \t" << ourOffset << "(%rbp), "
									<< "%rsi" << '\n';
						else if (paramCount == 2)
							asmFile << "\tmovq \t" << ourOffset << "(%rbp), "
									<< "%rdx" << '\n';
						else if (paramCount == 3)
							asmFile << "\tmovq \t" << ourOffset << "(%rbp), "
									<< "%rcx" << '\n';
						else
							asmFile << "\tmovq \t" << ourOffset << "(%rbp), "
									<< "%rdi" << '\n';
					}
					// If the type of the parameter is float
					else if (param_type == "float")
					{
						// If the count of floating-point parameters is less than 8
						if (floatParamCount < 8)
						{
							// Move the parameter from the memory location to the appropriate XMM register
							asmFile << "\tmovss\t" << ourOffset << "(%rbp), %xmm" << floatParamCount << "\n";
							floatParamCount++;
						}
						else
						{
							// Handle passing additional floating-point parameters on the stack or error
						}
					}
				}

				params.clear(); // Clear parameters after loading

				asmFile << "\tcall\t" << arg1 << '\n';
				asmFile << "\tmovl\t%eax, " << getOffset(res) << "(%rbp)";
			}

			else if (op == "func")
			{
				// This block handles the function declaration in assembly language

				// Write the function prologue
				asmFile << "\t.globl\t" << res << "\n";					// Declare the function as global
				asmFile << "\t.type\t" << res << ", @function\n";		// Specify the type of the function
				asmFile << res << ": \n";								// Label the function
				asmFile << ".LFB" << functionLabelCount << ":" << '\n'; // Start a function block
				asmFile << "\t.cfi_startproc" << '\n';					// Indicate the start of a function
				asmFile << "\tpushq \t%rbp" << '\n';					// Save the base pointer
				asmFile << "\t.cfi_def_cfa_offset 8" << '\n';			// Define the current CFA rule
				asmFile << "\t.cfi_offset 5, -8" << '\n';				// Remember the value of the base pointer
				asmFile << "\tmovq \t%rsp, %rbp" << '\n';				// Move the stack pointer to the base pointer
				asmFile << "\t.cfi_def_cfa_register 5" << '\n';			// Define the current CFA rule

				// Lookup the function in the global symbol table and get its nested symbol table
				ST = globalST->lookup(res)->nested;
				// Subtract the offset of the last symbol in the symbol table plus 24 from the stack pointer
				asmFile << "\tsubq\t$" << ST->symbols.back().offset + 24 << ", %rsp" << '\n';

				// Handle the function parameters
				int paramCount = 0;				 // Initialize the parameter count
				for (auto &symbol : ST->symbols) // Iterate over all symbols in the symbol table
				{
					if (symbol.category == "param") // If the symbol is a parameter
					{
						if (symbol.type->type == "int" || symbol.type->type == "char" || symbol.type->type == "ptr") // If the type of the parameter is int, char, or pointer
						{
							// Move the parameter from the appropriate register to the memory location based on the parameter count
							if (paramCount == 0)
								asmFile << "\tmovq\t%rdi, " << getOffset(symbol.name) << "(%rbp)";
							else if (paramCount == 1)
								asmFile << "\n\tmovq\t%rsi, " << getOffset(symbol.name) << "(%rbp)";
							else if (paramCount == 2)
								asmFile << "\n\tmovq\t%rdx, " << getOffset(symbol.name) << "(%rbp)";
							else if (paramCount == 3)
								asmFile << "\n\tmovq\t%rcx, " << getOffset(symbol.name) << "(%rbp)";
						}
						else if (symbol.type->type == "float") // If the type of the parameter is float
						{
							// Move the parameter from the appropriate XMM register to the memory location
							asmFile << "\tmovss\t%xmm" << paramCount << ", " << getOffset(symbol.name) << "(%rbp)\n";
						}
						else
						{
							// If the type of the parameter is not int, char, pointer, or float, do nothing
						}

						paramCount++; // Increment the parameter count
					}
					else
						break; // If the symbol is not a parameter, break the loop
				}
			}

			// epilogue of a function
			else if (op == "funcend")
			{

				asmFile << "\tleave\n";
				asmFile << "\t.cfi_restore 5\n";
				asmFile << "\t.cfi_def_cfa 4, 4\n";
				asmFile << "\tret\n";
				asmFile << "\t.cfi_endproc" << '\n';
				asmFile << ".LFE" << functionLabelCount++ << ":" << '\n';
				asmFile << "\t.size\t" << res << ", .-" << res;
			}
			else
			{
				asmFile << "\tnop";
			}

			asmFile << '\n';
		}
		opSerialNumber++;
	}
	asmFile.close();

	return;
}

int main(int argc, char *argv[])
{
	// Clear the label store
	label_store.clear();

	// Initialize the count of nested tables
	table_count = 0;

	// Create a new global symbol table
	globalST = new symtable("Global");

	// Set the current symbol table to the global symbol table
	ST = globalST;

	// Set the symbol table suffix to ".Global"
	symbolTableSuffix = ".Global";

	// Enable lookup inside parent symbol tables
	lookupInsideParent = true;

	// Clear the list of functions
	listOffunctions.clear();

	// Set the parent symbol table to NULL
	parent_ST = NULL;

	// Clear the loop name
	loop_name = "";

	// Append the input file name to the assembly file name and test file name
	asmFileName = asmFileName + argv[1];
	testFileName = testFileName + argv[1];

	// Parse the input file
	if (yyparse())
	{
		// If there is an error while parsing, print an error message
		cout << "Error while parsing\n";
	}
	else
	{
		// If parsing is successful, print all functions
		cout << "All functions\n";
		cout << listOffunctions.size() << "\n";
		for (auto funcs : listOffunctions)
		{
			cout << funcs->name << "\n";
			flattenFunctionSymbolTable(funcs);
		}

		// Update the global symbol table
		globalST->update();

		// Print all symbol tables
		cout << "\nSYMBOL TABLES:\n\n";
		globalST->print();

		// Print the three address codes
		cout << "\n";
		Q.print();

		// Generate the assembly code
		generateAsm();
	}
}
